<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Édipo Luis Féderle - Começando com Clojure e Emacs</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="logo">
              <a href="../">Édipo L. Féderle</a>
            </div>
            <nav>
              <a href="../misc.html">Misc</a>
              <a href="../academia.html">Academia</a>
              <a href="../archive.html">Archive</a>
              <a href="../contact.html">Contact</a>
              <a href="../about.html">About</a>
            </nav>
        </header>

        <main role="main">
            <h1>Começando com Clojure e Emacs</h1>
            <div class="info">
  Posted on March 25, 2017
  
</div>
<div class="info">
  
  Tags: clojure, emacs, programming
  
</div>

<p>Ei, tudo bem ?</p>
<p>Esse post tem como objetivo expor um passo-a-passo para quem tiver interesse em começar a utilizar a linguagem <a href="https://clojure.org">Clojure</a> com o editor <a href="https://www.gnu.org/s/emacs/">Emacs</a>.</p>
<p>Esse post não requer nenhum conhecimento prêvio em nenhum dos dois topícos. Se você apenas ouviu falar em Clojure e Emacs e deseja começar a olhar para esses assunto, quem sabe esse conteúdo pode lhe ajude.</p>
<!-- more -->
<p>Antes de tudo vamos fazer uma lista do que você precisa instalar em seu computador para seguir:</p>
<h2 id="jvm---java-virtual-machine">JVM - Java Virtual Machine</h2>
<p>Pense nisso como o software que roda os programas escritos em Clojure. Caso você esteja usando Linux ou OS X é provável que você já tenha isso instalado. Verifique usando o seguinte comando:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">which</span> java</a></code></pre></div>
<p>Se o comando anterior retornar algo como:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">/usr/bin/java</span></a></code></pre></div>
<p>Então você já tem o que precisa para seguir. Se você ver algo como java not found você precisa instalar a JDK na sua máquina. Siga esse link para isso.</p>
<h2 id="leinigen---ferramenta-de-build-para-clojure">Leinigen - Ferramenta de build para Clojure</h2>
<p>Você pode acessar a página do leinigen e ver as instruções de instalação para seu ambiente. O lein vai instalar a linguagem Clojure para você. Após isso você terá um novo comando disponível chamado lein.</p>
<p>Agora com tudo configurado podemos ir adiante e criar nosso primeiro projeto Clojure. Para isso, em seu terminal, execute o seguinte comando:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" title="1"><span class="ex">lein</span> new hello-world</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="bu">cd</span> hello-world</a></code></pre></div>
<p>O que o comando lein new hello-world faz é criar a estutura básica de um projeto clojure.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" title="1"><span class="ex">.</span></a>
<a class="sourceLine" id="cb4-2" title="2">├── <span class="ex">LICENSE</span></a>
<a class="sourceLine" id="cb4-3" title="3">├── <span class="ex">README.md</span></a>
<a class="sourceLine" id="cb4-4" title="4">├── <span class="ex">doc</span></a>
<a class="sourceLine" id="cb4-5" title="5">│   └── <span class="ex">intro.md</span></a>
<a class="sourceLine" id="cb4-6" title="6">├── <span class="ex">project.clj</span></a>
<a class="sourceLine" id="cb4-7" title="7">├── <span class="ex">resources</span></a>
<a class="sourceLine" id="cb4-8" title="8">├── <span class="ex">src</span></a>
<a class="sourceLine" id="cb4-9" title="9">│   └── <span class="ex">hello_world</span></a>
<a class="sourceLine" id="cb4-10" title="10">│       └── <span class="ex">core.clj</span></a>
<a class="sourceLine" id="cb4-11" title="11">└── <span class="bu">test</span></a>
<a class="sourceLine" id="cb4-12" title="12">└── <span class="ex">hello_world</span></a>
<a class="sourceLine" id="cb4-13" title="13">└── <span class="ex">core_test.clj</span></a></code></pre></div>
<p>O primeiro arquivo importante é o project.clj. Seu conteúdo é o seguinte:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb5-1" title="1">(defproject hello-world <span class="st">&quot;0.1.0-SNAPSHOT&quot;</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="at">:description</span> <span class="st">&quot;FIXME: write description&quot;</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="at">:url</span> <span class="st">&quot;http://example.com/FIXME&quot;</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="at">:license</span> {<span class="at">:name</span> <span class="st">&quot;Eclipse Public License&quot;</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="at">:url</span> <span class="st">&quot;http://www.eclipse.org/legal/epl-v10.html&quot;</span>}</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="at">:dependencies</span> [[org.clojure/clojure <span class="st">&quot;1.7.0&quot;</span>]])</a></code></pre></div>
<p>Primeiramente temos o nome do nosso projeto e a versão, sem seguida algumas informações relavantes como uma descrição, url e a licença que seu projeto usa. O mais importante aqui, que você deve tomar atenção agora, é a última linha, dependencies: ela faz justamente o que você pensa, especifica quais as dependências seu projeto utiliza, até o momento temos apenas a própria linguagem Clojure na versão 1.7.0.</p>
<p>Vamos seguir em frente e dar uma olhada no próximo arquivo relevante para nós nesse ponto: <code>src\hello_world\core.clj</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb6-1" title="1">(<span class="kw">ns</span> hello-world.core</a>
<a class="sourceLine" id="cb6-2" title="2"></a>
<a class="sourceLine" id="cb6-3" title="3">(<span class="bu">defn</span><span class="fu"> foo</span></a>
<a class="sourceLine" id="cb6-4" title="4"> <span class="st">&quot;I don't do a whole lot.&quot;</span></a>
<a class="sourceLine" id="cb6-5" title="5"> [x]</a>
<a class="sourceLine" id="cb6-6" title="6"> (<span class="kw">println</span> x <span class="st">&quot;Hello, World!&quot;</span>))</a></code></pre></div>
<p>Quando criamos o projeto <code>hello-world</code> a ferramenta <code>lein</code> já adicionou um código em nosso arquivo <code>core.clj</code>. Na linha <code>1</code> temos a definição do que chamamos de <em>namespace</em>. Se você vem do mundo Java pense nisso como um pacote. Nesse caso nosso namespacese chama-se <code>hello-world.core</code>.</p>
<p>Entre as linhas <code>3</code> e <code>6</code> temos a definição de uma função em Clojure. Na linha <code>3</code> nomeamos a função como <code>foo</code>. A linha <code>4</code> se chama <strong>docstring</strong> e é onde você descreve o que a função faz.</p>
<p>A linha <code>5</code> é onde especificamos os argumentos que a função vai receber, nesse caso apenas um: <code>x</code>. Por fim a linha <code>6</code> é o corpo da função propriamente dito. Aqui apenas estamos exibindo em tela o valor de <code>x</code> juntamente com a frase “Hello, World”.</p>
<p>Certo, entendi! Mas como faço para executar isso? Boa pergunta! Ainda lembra do <strong>lein</strong> certo? Agora vamos usar algo chamado <strong>REPL</strong>, que significa <strong>READ</strong>, <strong>EVAL</strong>, <strong>PRINT</strong>, <strong>LOOP</strong>. Vamos usar o <strong>lein</strong> para vermos na prática. No terminal:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="ex">lein</span> repl</a></code></pre></div>
<p>Após alguns segundos, você irá ver algo como:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb8-1" title="1">Clojure <span class="dv">1</span>.<span class="fl">7.0</span></a>
<a class="sourceLine" id="cb8-2" title="2">Java HotSpot(TM) <span class="dv">64</span>-Bit Server VM <span class="dv">1</span>.<span class="fl">7.0</span>_<span class="dv">79</span>-b15</a>
<a class="sourceLine" id="cb8-3" title="3">Docs: (<span class="kw">doc</span> function-name-here)</a>
<a class="sourceLine" id="cb8-4" title="4">(<span class="kw">find-doc</span> <span class="st">&quot;part-of-name-here&quot;</span>)</a>
<a class="sourceLine" id="cb8-5" title="5">Source: (source function-name-here)</a>
<a class="sourceLine" id="cb8-6" title="6">Javadoc: (javadoc java-object-or-class-here)</a>
<a class="sourceLine" id="cb8-7" title="7">Exit: Control+D <span class="kw">or</span> (exit) <span class="kw">or</span> (quit)</a>
<a class="sourceLine" id="cb8-8" title="8">Results: Stored in vars <span class="va">*1</span>, <span class="va">*2</span>, <span class="va">*3</span>, an exception in <span class="va">*e</span></a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10">user=&gt;</a></code></pre></div>
<p>Pense no <strong>REPL</strong> como um prompt onde você pode interagir com a linguagem e também com seu programa. Está vendo esse <code>user=&gt;</code> ? É o <em>namespace</em> chamado <code>user</code>. Você pode confirmar isso executando e seguinte no <strong>REPL</strong>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="va">user=</span><span class="op">&gt;</span> <span class="ex">*ns*</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="co">#namespace[user]</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="va">user=</span><span class="op">&gt;</span></a></code></pre></div>
<p>Nossa função <code>foo</code> encontra-se em outro <em>namespace</em> precisamos usar o <code>require</code> agora:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1"><span class="va">user=</span><span class="op">&gt;</span> <span class="kw">(</span><span class="ex">require</span> <span class="st">'hello-world.core)</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="st">nil</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="st">user=&gt; (hello-world.core/foo &quot;Jhon&quot;)</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="st">Jhon Hello, World!</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="st">nil</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="st">user=&gt;</span></a></code></pre></div>
<p>Agora teste usar o seguinte comando:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="va">user=</span><span class="op">&gt;</span> <span class="kw">(</span><span class="ex">doc</span> map<span class="kw">)</span></a></code></pre></div>
<p>Agora você já sabe como olhar para a documentação de um função que esteja com dúvidas.</p>
<p>Ótimo, conseguimos! Podemos parar por aqui, já que esse artigo não é sobre aprender a linguagem Clojure, de fato. O próximo arquivo que vamos olhar é o <code>test/hello_word/core_test.clj</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb12-1" title="1">(<span class="kw">ns</span> hello-world.core-test</a>
<a class="sourceLine" id="cb12-2" title="2">   (<span class="at">:require</span> [clojure.<span class="kw">test</span> <span class="at">:refer</span> <span class="at">:all</span>]</a>
<a class="sourceLine" id="cb12-3" title="3">			 [hello-world.core <span class="at">:refer</span> <span class="at">:all</span>]))</a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5">(<span class="bu">deftest</span><span class="fu"> a-test</span></a>
<a class="sourceLine" id="cb12-6" title="6">   (<span class="kw">testing</span> <span class="st">&quot;FIXME, I fail.&quot;</span></a>
<a class="sourceLine" id="cb12-7" title="7">   (<span class="kw">is</span> (<span class="kw">=</span> <span class="dv">0</span> <span class="dv">1</span>))))</a></code></pre></div>
<p>Novamente, não vamos focar em detalhes, olhe para a linha <code>7</code>. Você pode ler essa linha como <code>0</code> É igual a <code>1</code>?. Vamos voltar para o terminal e novamente usar o <strong>lein</strong>, dessa vez para executar o(s) teste(s):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1">✝  <span class="ex">~/hello-world</span> <span class="op">&gt;</span> lein test</a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="ex">lein</span> test hello-world.core-test</a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="ex">lein</span> test :only hello-world.core-test/a-test</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="ex">FAIL</span> in (a-test) <span class="kw">(</span><span class="ex">core_test.clj</span>:7<span class="kw">)</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="ex">FIXME</span>, I fail.</a>
<a class="sourceLine" id="cb13-9" title="9"><span class="ex">expected</span>: (= 0 1)</a>
<a class="sourceLine" id="cb13-10" title="10"><span class="ex">actual</span>: (not (= 0 1))</a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ex">Ran</span> 1 tests containing 1 assertions.</a>
<a class="sourceLine" id="cb13-13" title="13"><span class="ex">1</span> failures, 0 errors.</a>
<a class="sourceLine" id="cb13-14" title="14"><span class="ex">Tests</span> failed.</a>
<a class="sourceLine" id="cb13-15" title="15"><span class="ex">Olhe</span> para as seguintes linhas:</a>
<a class="sourceLine" id="cb13-16" title="16"></a>
<a class="sourceLine" id="cb13-17" title="17"><span class="ex">expected</span>: (= 0 1)</a>
<a class="sourceLine" id="cb13-18" title="18"><span class="ex">actual</span>: (not (= 0 1))</a></code></pre></div>
<p>Por incrível que parece <code>0</code> não É igual a <code>1</code> :D. Você já sabe como fazer esse teste passar né? Abra o arquivo <code>test/hello_word/core_test.clj</code> modifique o teste de modo que ele passe e rode <strong>lein</strong> test novamente:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" title="1">✘ ✝  <span class="ex">~/hello-world</span> <span class="op">&gt;</span> lein test</a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="ex">lein</span> test hello-world.core-test</a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="ex">Ran</span> 1 tests containing 1 assertions.</a>
<a class="sourceLine" id="cb14-6" title="6"><span class="ex">0</span> failures, 0 errors.</a></code></pre></div>
<p>Parabéns, você acaba de fazer seu primeiro teste em Clojure passar!</p>
<h2 id="hora-do-emacs">Hora do Emacs</h2>
<p>Até agora não utilizamos nenhuma editor de texto ou IDE para trabalhar em nosso projeto. Bem, isso não é totalmente verdade, afinal você usou algo para corrigir o teste anteriror, certo?. Agora vamos configurar um ambiente mínimo para trabalhar com clojure utilizando o editor Emacs. Vamos utilizar o Emacs juntamente com o <strong>CIDER</strong> (Clojure Interactive Development Environment that Rocks).</p>
<p>Primeiramente você precisa instalar o Emacs, claro. Novamente, se você estiver no OS X, baixe e instale usando esse link. Se estiver no Linux, Ubuntu por exemplo, você pode dar uma olhada aqui. Por fim, se estiver no Windows olhe aqui.</p>
<p>Aqui estarei usando OS X, o que deve servir igualmente para o Linux. Infelizmente não sei como isso tudo se comporta em Windows, então, me desculpe. Ao iniciar o Emacs você irá ver a seguinte tela:</p>
<p><img src="https://www.dropbox.com/s/bt9qlg4goyo56ml/emacs-initial.png?raw=1" /></p>
<p>Em destaque na imagem acima temos:</p>
<p><strong>Nome do Buffer</strong> - Todo trabalho feito dentro do Emacs ocorre em Buffers. Ao iniciar o emacs somos automaticamente postos no buffer chamado GNU Emacs.</p>
<p><strong>mode</strong> - Buffers possui um modo (mode), esse modo determina o comportamento do editor enquanto está no buffer atual. O modo mais básico e menos especializado é o Fundamental.</p>
<p><strong>minibuffer</strong> - É de onde o Emacs lê comando mais complexo, como nomes de arquivos, comandos do próprio Emacs ou expresões Lisp.</p>
<h3 id="comandos-básicos">Comandos básicos</h3>
<p>Abaixo uma pequena lista de alguns poucos comandos para você começar no Emacs:</p>
<p><strong>C-x b</strong> - Mudar entre buffers. Utilize esse comando e o nome do buffer desejado (o mesmo para criar um novo)</p>
<p><strong>C-x b</strong> - Para abrir um arquivo. Use TAB para autocompletar</p>
<p><strong>C-x C-s</strong> - Para salvar um buffer, criando assim um arquivo</p>
<p><strong>C-X C-f</strong> - Para criar um arquivo novo. Utilize esse comando e entre com o caminho para o novo arquivo. Use TAB para autocompletar</p>
<p><strong>M-w</strong> - Copiar (Kill-ring-save) onde M é a tecla Option no OS X ou Alt. Entretanto você pode usar o tradicional C-c</p>
<p><strong>C-y</strong> - Colar (Yank). Entretanto você pode usar o tradicional C-v</p>
<p><strong>C-X C-c</strong> - Para sair</p>
<p>Por hora esses comandos são o suficiente.</p>
<h3 id="configurações-básicas">Configurações básicas</h3>
<p>Agora vamos partir para a parte mais legal do Emacs: customizações. Mesmo o que vamos fazer aqui parecer extremamente simples, é um começo para você ter uma ideia do que é possível ser feito.</p>
<pre class="emacs-lisp"><code>;; Inibe tela 'inicial', *scratch* buffer será exibido
(setq inhibit-startup-screen t)

;; Remover a barra superior.
(when (fboundp 'tool-bar-mode)
(tool-bar-mode -1))

;; Removendo scroolbars nativas do OS, redundantes
(when (fboundp 'scroll-bar-mode)
(scroll-bar-mode -1))

;; Aumentar a fonte um pouco
(set-face-attribute 'default nil :height 130)

;; Fazer cursor parar de piscar
(blink-cursor-mode 0)

;; Mostrar o path completo para o arquivo na barra superior
(setq-default frame-title-format &quot;%b (%f)&quot;)</code></pre>
<p>Crie o arquivo ~/.emacs.d/init.el, use o próprio Emacs, utilize os comandos que você acabou de aprender, e adicione o conteúdo acima. Esse código é Emacs-Lisp e com ele você pode configurar tudo o que desejar no Emacs. Emacs-Lisp também é a linguagem usada para estender o editor com mais funcionalidades, como por exemplo outros modos (modes). Agora feche e abra novamente o Emacs. Ele vai se parecer com isso:</p>
<p><img src="https://www.dropbox.com/s/igg6hkhu70s3zij/emacs-initial-2.png?raw=1" /></p>
<p>Essas são apenas algumas configurações básicas, com o tempo você pode explorar mais e fazer as customizações que desejar. Vamos seguir em frente e configurar o CIDER em nosso Emacs.</p>
<p>Volte para o arquivo<code>~/.emacs.d/init.el</code>e adicione o seguinte no final do arquivo:</p>
<pre class="emacs-lisp"><code>;; ;; Packages

(require 'package)
(package-initialize)

(setq package-archives '((&quot;gnu&quot; . &quot;http://elpa.gnu.org/packages/&quot;)
	(&quot;marmalade&quot; . &quot;http://marmalade-repo.org/packages/&quot;)
	(&quot;melpa&quot; . &quot;http://melpa.org/packages/&quot;)))

;; instala o CIDER se ainda não estiver instalado
(unless (package-installed-p 'cider)
(package-install 'cider))</code></pre>
<p>Reinicie o Emacs ou execute <code>M-x eval-buffer</code>. Esse comando irá avaliar o conteúdo completo do buffer atual.</p>
<p>Agora vamos acessar nosso projeto Clojure e iniciar o REPL usando o CIDER. Para isso, no Emacs, navegue até o diretório raiz do projeto <code>hello-world</code>. Utilize o comando <code>C-x f</code> para isso. Uma vez no diretório raiz, você verá algo assim:</p>
<p><img src="https://www.dropbox.com/s/v1ohzc4wyecr5o4/emacs-project-files.png?raw=1" /></p>
<p>Agora vamos finalmente conectar nosso projeto ao <strong>REPL</strong> utilizando o CIDER. Para isso utilize <code>M-x cider-jack-in</code>. Você deve ver algo assim:</p>
<p><img src="https://www.dropbox.com/s/yll8nho9gvtiz43/emacs-cider-1.png?raw=1" /></p>
<p>Agora que configuramos o CIDER em nosso Emacs, vamos navegar até o arquivo core.clj. Após isso vamos ajustar um pouco os buffers, para deixar do lado esquerdo o código fonte e do lado direito o REPL. Utilize <code>C-X 3</code> para dividir o editor em dois buffers verticais e <code>C-X</code> o para alternar para o buffer da direita. Por fim, <code>C-x b *cider-repl hello-world*</code> para abrir o buffer contendo o <strong>REPL</strong>.</p>
<p><img src="https://www.dropbox.com/s/0l2rs7ei8v2hqxf/emacs-cider-2.png?raw=1" /></p>
<p>Antes de continuar, vamos adicionar mais uma configuração ao arquivo <code>init.el</code>:</p>
<p><code>(setq cider-repl-display-help-banner nil)</code></p>
<p>Isso desabilita a exibição de ajuda ao inicial o CIDER.</p>
<p>Agora temos o REPL e nosso código em um mesmo local. Vá em frente e tente executar o seguinte no REPL.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb17-1" title="1">(<span class="kw">+</span> <span class="dv">10</span> <span class="dv">10</span> <span class="dv">10</span>) <span class="co">; mesmo que 10 + 10 + 10</span></a>
<a class="sourceLine" id="cb17-2" title="2">(<span class="kw">apply</span> <span class="kw">+</span> `[<span class="dv">10</span> <span class="dv">10</span> <span class="dv">10</span>]) <span class="co">; soma todos os valores do vector</span></a></code></pre></div>
<p>Altere para o código fonte, lembra como faz isso né? Vamos dar uma olhada em alguns comandos básicos que são essenciais para começar:</p>
<p><strong>C-C C-e</strong> - avaliar a expressão imediatamente após o cursor. O resultado será mostrado no <em>minibuffer</em> e também ao lado da expressão avaliada, como:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode clojure"><code class="sourceCode clojure"><a class="sourceLine" id="cb18-1" title="1">(<span class="kw">map</span> (<span class="kw">fn</span> [x] (<span class="kw">*</span> <span class="dv">2</span> x)) `[<span class="dv">2</span> <span class="dv">4</span> <span class="dv">6</span>]) =&gt; (<span class="dv">4</span> <span class="dv">8</span> <span class="dv">12</span>)</a></code></pre></div>
<p><strong>C-C M-e</strong> - mesmo que o comando acima, porém o resultado é enviado para o REPL</p>
<p><strong>C-c C-k</strong> - avalia todo o conteúdo do buffer</p>
<p><strong>C-c C-d d</strong> - exibe a documentação para para a função sobre o cursor, o mesmo que (doc function). Posicione o cursor sobre a funcão que deseja visualizar a documentação e execute o comando. Você pode executar isso tanto em um buffer quanto no REPL</p>
<p><img src="https://www.dropbox.com/s/74oj2wecswvnx65/emacs-cider-docs.png?raw=1" /></p>
<p><strong>C-c M-n</strong> - Mudar o namespace no REPL. Lembre-se que mudar para um namespace não avalia o conteúdo do mesmo. Para isso use o comando que você aprendeu anteriormente.</p>
<p><strong>C-c C-t p</strong> - Para rodar os testes do projeto inteiro</p>
<p><strong>C-c C-t n</strong> - Para rodar os testes apenas do namespace atual</p>
<p><strong>C-c C-q</strong> - E claro, você precisa sair do CIDER um dia. Isso fecha o REPL</p>
<h2 id="seguindo-em-frente">Seguindo em frente</h2>
<p>Esse post deu uma visão geral sobre como começar usar Clojure juntamente com o Emacs. Inicialmente foi mostrado como rodar Clojure em sua máquina, introduzindo o Leingen. Vimos como usar o lein para criar um projeto básico Clojure. Aprendemos o que é o <strong>REPL</strong> e o básico para utilizá-lo para explorar a linguagem e seu programa. Também introduzimos o editor Emacs, aprendendo alguns comandos básicos para sobrivivência nos primeiros dias. Realizamos algumas customizações no editor e instalamos o <strong>CIDER</strong>. Por fim aprendemos alguns comandos essenciais do <strong>CIDER</strong></p>
<p>Você pode seguir olhando para os seguintes recursos:</p>
<p><a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">Why Functional Programming Matters</a> <a href="http://emacsrocks.com">Emacs Rocks</a> <a href="http://www.braveclojure.com">Clojure for the Brave and True</a> <a href="https://clojuredocs.org">ClojureDocs</a></p>
<h2 id="referências">Referências</h2>
<p>http://leiningen.org https://clojure.org https://www.gnu.org/software/emacs/ https://github.com/clojure-emacs/cider https://www.gnu.org/software/emacs/manual/eintr.htmlr</p>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
